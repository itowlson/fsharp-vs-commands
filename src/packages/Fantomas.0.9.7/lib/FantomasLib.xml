<?xml version="1.0" encoding="utf-8"?>
<doc>
<assembly><name>FantomasLib</name></assembly>
<members>
<member name="">

</member>
<member name="T:Fantomas.AssemblyInfo">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Fantomas.CodeFormatter.tryFormatSelectionFromString(System.Boolean,Microsoft.FSharp.Compiler.Range.range,System.String,Fantomas.FormatConfig.FormatConfig)">
<summary>
 Realign results on the correct column
 Format selection in range r and keep other parts unchanged; return None if failed
</summary>
</member>
<member name="M:Fantomas.CodeFormatter.formatSelectionFromString(System.Boolean,Microsoft.FSharp.Compiler.Range.range,System.String,Fantomas.FormatConfig.FormatConfig)">
<summary>
 Value 4 accounts for length of &quot;and &quot;
 Format a selected part of source string using given config; keep other parts unchanged. 
</summary>
</member>
<member name="M:Fantomas.CodeFormatter.getPatch(System.Int32,System.String[])">
<summary>
 Find the first type declaration or let binding at beginnings of lines
</summary>
</member>
<member name="">

</member>
<member name="M:Fantomas.CodeFormatter.getEndCol(Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.SourceCodeServices.LineTokenizer,Microsoft.FSharp.Core.FSharpRef{System.Int64})">
<summary>
 Find out the end token
</summary>
</member>
<member name="M:Fantomas.CodeFormatter.getStartCol(Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.SourceCodeServices.LineTokenizer,Microsoft.FSharp.Core.FSharpRef{System.Int64})">
<summary>
 Find out the start token
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Fantomas.CodeFormatter.getStartLine(System.String[],System.Int32)">
<summary>
 Get first non-whitespace line
</summary>
</member>
<member name="M:Fantomas.CodeFormatter.makeRange(System.Int32,System.Int32,System.Int32,System.Int32)">
<summary>
 Make a range from (startLine, startCol) to (endLine, endCol) to select some text
</summary>
</member>
<member name="M:Fantomas.CodeFormatter.stringPos(Microsoft.FSharp.Compiler.Range.range,System.String)">
<summary>
 Convert from range to string positions
</summary>
</member>
<member name="M:Fantomas.CodeFormatter.tryProcessSourceFile(System.String,System.IO.TextWriter,Fantomas.FormatConfig.FormatConfig)">
<summary>
 Format inFile and write to text writer; return None if failed
</summary>
</member>
<member name="M:Fantomas.CodeFormatter.processSourceFile(System.String,System.IO.TextWriter,Fantomas.FormatConfig.FormatConfig)">
<summary>
 Format inFile and write to text writer
</summary>
</member>
<member name="M:Fantomas.CodeFormatter.tryProcessSourceString(System.Boolean,System.String,System.IO.TextWriter,Fantomas.FormatConfig.FormatConfig)">
<summary>
 Format a source string using given config and write to a text writer; return None if failed
</summary>
</member>
<member name="M:Fantomas.CodeFormatter.processSourceString(System.Boolean,System.String,System.IO.TextWriter,Fantomas.FormatConfig.FormatConfig)">
<summary>
 Format a source string using given config and write to a text writer
</summary>
</member>
<member name="M:Fantomas.CodeFormatter.tryFormatSourceString(System.Boolean,System.String,Fantomas.FormatConfig.FormatConfig)">
<summary>
 Format a source string using given config; return None if failed
</summary>
</member>
<member name="M:Fantomas.CodeFormatter.formatSourceString(System.Boolean,System.String,Fantomas.FormatConfig.FormatConfig)">
<summary>
 Format a source string using given config
</summary>
</member>
<member name="M:Fantomas.CodeFormatter.parse(System.Boolean,System.String)">
<summary>
 Parse a source code string
</summary>
</member>
<member name="">

</member>
<member name="T:Fantomas.CodeFormatter">

</member>
<member name="">

</member>
<member name="M:Fantomas.CodePrinter.genPatRecordFieldName(System.Tuple{Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Ast.Ident},Microsoft.FSharp.Compiler.Ast.Ident},Microsoft.FSharp.Compiler.Ast.SynPat)">
<summary>
 Remove parentheses on an extremely simple pattern
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Fantomas.CodePrinter.genMemberDefnList(System.Boolean,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Ast.SynMemberDefn})">
<summary>
 Each multiline member definition has a pre and post new line. 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Fantomas.CodePrinter.genTypeConstraint(Microsoft.FSharp.Compiler.Ast.SynTypeConstraint)">
<summary>
 There is a potential parser bug with &quot;&lt;^T...&quot;
</summary>
</member>
<member name="">

</member>
<member name="M:Fantomas.CodePrinter.genTypeList(Microsoft.FSharp.Collections.FSharpList{System.Tuple{Microsoft.FSharp.Compiler.Ast.SynType,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Ast.SynArgInfo}}})">
<summary>
 Inner parts should have brackets for separation
</summary>
</member>
<member name="M:Fantomas.CodePrinter.genComplexType(Microsoft.FSharp.Compiler.Ast.SynType)">
<summary>
 Some patterns could cause a parsing error
</summary>
</member>
<member name="M:Fantomas.CodePrinter.genPrefixTypes(Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Ast.SynType})">
<summary>
 The surrounding brackets aren&apos;t always neccessary
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Fantomas.CodePrinter.genMemberSig(Microsoft.FSharp.Compiler.Ast.SynMemberSig)">
<summary>
 Add newline after un-indent to be spacing-correct
 Remember that we use MemberSig of parent node
</summary>
</member>
<member name="M:Fantomas.CodePrinter.genSigTypeDefn(System.Boolean,Microsoft.FSharp.Compiler.Ast.SynTypeDefnSig)">
<summary>
 Remember that we use MemberDefn of parent node
</summary>
</member>
<member name="">

</member>
<member name="M:Fantomas.CodePrinter.genIndexedVars(Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Ast.SynExpr})">
<summary>
 Use in indexed set and get only
</summary>
</member>
<member name="M:Fantomas.CodePrinter.genInfixApps(System.Boolean,Microsoft.FSharp.Collections.FSharpList{System.Tuple{System.String,Microsoft.FSharp.Compiler.Ast.SynExpr}})">
<summary>
 and is applicable for use binding
 Could customize a bit if e is single line
 It seems too annoying to use sepSemiNln
 A generalization of IfThenElse
 At this stage, all symbolic operators have been handled.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Fantomas.CodePrinter.genMemberFlags(System.Boolean,Microsoft.FSharp.Compiler.Ast.MemberFlags)">
<summary>
 Handle special &quot;then&quot; block in constructors
</summary>
</member>
<member name="">

</member>
<member name="M:Fantomas.CodePrinter.genMemberBindingList(System.Boolean,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Ast.SynBinding})">
<summary>
 Value inter indicates printing in a interface definition. 
 Each member is separated by a new line.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Fantomas.CodePrinter.autoBreakNln(Microsoft.FSharp.Compiler.Ast.SynExpr)">
<summary>
 These inline functions have to be defined before their uses
</summary>
</member>
<member name="M:Fantomas.CodePrinter.genPreXmlDoc(Microsoft.FSharp.Compiler.Ast.PreXmlDoc)">
<summary>
 Special treatment for function application on attributes
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Fantomas.CodePrinter">

</member>
<member name="F:Fantomas.FormatConfig.Context.Comments">
<summary>
 Comments attached to appropriate locations
</summary>
</member>
<member name="F:Fantomas.FormatConfig.Context.Positions">
<summary>
 Positions of new lines in the original source string
</summary>
</member>
<member name="F:Fantomas.FormatConfig.Context.Content">
<summary>
 The original source string to query as a last resort 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:Fantomas.FormatConfig.Context.Default">
<summary>
 Initialize with a string writer and use space as delimiter
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:Fantomas.FormatConfig.ColumnIndentedTextWriter.Column(System.Int32)">
<summary>
 Current column of the page in an absolute manner
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:Fantomas.FormatConfig.ColumnIndentedTextWriter.Column">
<summary>
 Current column of the page in an absolute manner
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Fantomas.FormatConfig.ColumnIndentedTextWriter">
<summary>
 Wrapping IndentedTextWriter with a current column position
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="F:Fantomas.FormatConfig.FormatConfig.PageWidth">
<summary>
 The column where we break to new lines
</summary>
</member>
<member name="F:Fantomas.FormatConfig.FormatConfig.IndentSpaceNum">
<summary>
 Number of spaces for each indentation
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:Fantomas.FormatConfig.NoBreakInfixOps">
<summary>
 Never break into newlines on these operators
</summary>
</member>
<member name="P:Fantomas.FormatConfig.NewLineInfixOps">
<summary>
 Always break into newlines on these operators
</summary>
</member>
<member name="P:Fantomas.FormatConfig.NoSpaceInfixOps">
<summary>
 Don&apos;t put space before and after these operators
</summary>
</member>
<member name="M:Fantomas.FormatConfig.unindentOnWith(Fantomas.FormatConfig.Context)">
<summary>
 Conditional unindentation on with keyword
</summary>
</member>
<member name="M:Fantomas.FormatConfig.indentOnWith(Fantomas.FormatConfig.Context)">
<summary>
 Conditional indentation on with keyword
</summary>
</member>
<member name="M:Fantomas.FormatConfig.sepBeforeArg(Fantomas.FormatConfig.Context)">
<summary>
 sepNln part is essential to indentation
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Fantomas.FormatConfig.noNln(Microsoft.FSharp.Core.FSharpFunc{Fantomas.FormatConfig.Context,Fantomas.FormatConfig.Context},Fantomas.FormatConfig.Context)">
<summary>
 Skip all auto-breaking newlines
</summary>
</member>
<member name="M:Fantomas.FormatConfig.colAutoNlnSkip0``1(Microsoft.FSharp.Core.FSharpFunc{Fantomas.FormatConfig.Context,Fantomas.FormatConfig.Context},System.Collections.Generic.IEnumerable{``0},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{Fantomas.FormatConfig.Context,Fantomas.FormatConfig.Context}},Fantomas.FormatConfig.Context)">
<summary>
 This isn&apos;t accurate if we go to new lines
 Similar to col, skip auto newline for index 0
</summary>
</member>
<member name="M:Fantomas.FormatConfig.autoNln(Microsoft.FSharp.Core.FSharpFunc{Fantomas.FormatConfig.Context,Fantomas.FormatConfig.Context},Fantomas.FormatConfig.Context)">
<summary>
 Set a checkpoint to break at an appropriate column
</summary>
</member>
<member name="P:Fantomas.FormatConfig.sepCloseT">
<summary>
 closing token of tuple
</summary>
</member>
<member name="P:Fantomas.FormatConfig.sepOpenT">
<summary>
 opening token of tuple
</summary>
</member>
<member name="P:Fantomas.FormatConfig.sepCloseS">
<summary>
 closing token of sequence
</summary>
</member>
<member name="P:Fantomas.FormatConfig.sepOpenS">
<summary>
 opening token of sequence
</summary>
</member>
<member name="P:Fantomas.FormatConfig.sepCloseA">
<summary>
 closing token of array
</summary>
</member>
<member name="P:Fantomas.FormatConfig.sepOpenA">
<summary>
 opening token of array
</summary>
</member>
<member name="P:Fantomas.FormatConfig.sepCloseL">
<summary>
 closing token of list
</summary>
</member>
<member name="P:Fantomas.FormatConfig.sepOpenL">
<summary>
 opening token of list
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Fantomas.FormatConfig.rep(System.Int32,Microsoft.FSharp.Core.FSharpFunc{Fantomas.FormatConfig.Context,Fantomas.FormatConfig.Context},Fantomas.FormatConfig.Context)">
<summary>
 Repeat application of a function n times
</summary>
</member>
<member name="M:Fantomas.FormatConfig.ifElse(System.Boolean,Microsoft.FSharp.Core.FSharpFunc{Fantomas.FormatConfig.Context,Fantomas.FormatConfig.Context},Microsoft.FSharp.Core.FSharpFunc{Fantomas.FormatConfig.Context,Fantomas.FormatConfig.Context},Fantomas.FormatConfig.Context)">
<summary>
 b is true, apply f1 otherwise apply f2
</summary>
</member>
<member name="M:Fantomas.FormatConfig.optPre``1(Microsoft.FSharp.Core.FSharpFunc{Fantomas.FormatConfig.Context,Fantomas.FormatConfig.Context},Microsoft.FSharp.Core.FSharpFunc{Fantomas.FormatConfig.Context,Fantomas.FormatConfig.Context},Microsoft.FSharp.Core.FSharpOption{``0},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{Fantomas.FormatConfig.Context,Fantomas.FormatConfig.Context}},Fantomas.FormatConfig.Context)">
<summary>
 Similar to opt, but apply f2 at the beginning if there is a value
</summary>
</member>
<member name="M:Fantomas.FormatConfig.opt``1(Microsoft.FSharp.Core.FSharpFunc{Fantomas.FormatConfig.Context,Fantomas.FormatConfig.Context},Microsoft.FSharp.Core.FSharpOption{``0},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{Fantomas.FormatConfig.Context,Fantomas.FormatConfig.Context}},Fantomas.FormatConfig.Context)">
<summary>
 If there is a value, apply f and f&apos; accordingly, otherwise do nothing
</summary>
</member>
<member name="M:Fantomas.FormatConfig.colPre``1(Microsoft.FSharp.Core.FSharpFunc{Fantomas.FormatConfig.Context,Fantomas.FormatConfig.Context},Microsoft.FSharp.Core.FSharpFunc{Fantomas.FormatConfig.Context,Fantomas.FormatConfig.Context},System.Collections.Generic.IEnumerable{``0},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{Fantomas.FormatConfig.Context,Fantomas.FormatConfig.Context}},Fantomas.FormatConfig.Context)">
<summary>
 Similar to col, apply one more function f2 at the beginning if the input sequence is not empty
</summary>
</member>
<member name="M:Fantomas.FormatConfig.colPost``1(Microsoft.FSharp.Core.FSharpFunc{Fantomas.FormatConfig.Context,Fantomas.FormatConfig.Context},Microsoft.FSharp.Core.FSharpFunc{Fantomas.FormatConfig.Context,Fantomas.FormatConfig.Context},System.Collections.Generic.IEnumerable{``0},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{Fantomas.FormatConfig.Context,Fantomas.FormatConfig.Context}},Fantomas.FormatConfig.Context)">
<summary>
 Similar to col, apply one more function f2 at the end if the input sequence is not empty
</summary>
</member>
<member name="M:Fantomas.FormatConfig.col``1(Microsoft.FSharp.Core.FSharpFunc{Fantomas.FormatConfig.Context,Fantomas.FormatConfig.Context},System.Collections.Generic.IEnumerable{``0},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{Fantomas.FormatConfig.Context,Fantomas.FormatConfig.Context}},Fantomas.FormatConfig.Context)">
<summary>
 Process collection - keeps context through the whole processing
 calls f for every element in sequence and f&apos; between every two elements 
 as a separator. This is a variant that works on typed collections.
</summary>
</member>
<member name="M:Fantomas.FormatConfig.coli``1(Microsoft.FSharp.Core.FSharpFunc{Fantomas.FormatConfig.Context,Fantomas.FormatConfig.Context},System.Collections.Generic.IEnumerable{``0},Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{Fantomas.FormatConfig.Context,Fantomas.FormatConfig.Context}}},Fantomas.FormatConfig.Context)">
<summary>
 Similar to col, and supply index as well
</summary>
</member>
<member name="M:Fantomas.FormatConfig.str``1(``0,Fantomas.FormatConfig.Context)">
<summary>
 Print object converted to string
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Fantomas.FormatConfig.op_MinusMinus(Microsoft.FSharp.Core.FSharpFunc{Fantomas.FormatConfig.Context,Fantomas.FormatConfig.Context},System.String,Fantomas.FormatConfig.Context)">
<summary>
 Append specified string without line-break
</summary>
</member>
<member name="M:Fantomas.FormatConfig.op_PlusPlus(Microsoft.FSharp.Core.FSharpFunc{Fantomas.FormatConfig.Context,Fantomas.FormatConfig.Context},System.String,Fantomas.FormatConfig.Context)">
<summary>
 Break-line and append specified string
</summary>
</member>
<member name="M:Fantomas.FormatConfig.op_PlusGreater(Microsoft.FSharp.Core.FSharpFunc{Fantomas.FormatConfig.Context,Fantomas.FormatConfig.Context},Microsoft.FSharp.Core.FSharpFunc{Fantomas.FormatConfig.Context,Fantomas.FormatConfig.Context},Fantomas.FormatConfig.Context)">
<summary>
 Function composition operator
</summary>
</member>
<member name="M:Fantomas.FormatConfig.atCurrentColumn(Microsoft.FSharp.Core.FSharpFunc{Fantomas.FormatConfig.Context,Fantomas.FormatConfig.Context},Fantomas.FormatConfig.Context)">
<summary>
 Write everything at current column indentation
</summary>
</member>
<member name="M:Fantomas.FormatConfig.atIndentLevel(System.Int32,Microsoft.FSharp.Core.FSharpFunc{Fantomas.FormatConfig.Context,Fantomas.FormatConfig.Context},Fantomas.FormatConfig.Context)">
<summary>
 Apply function f at an absolute indent level (use with care)
</summary>
</member>
<member name="M:Fantomas.FormatConfig.decrIndent(System.Int32,Fantomas.FormatConfig.Context)">
<summary>
 Decrease indent by i spaces
</summary>
</member>
<member name="M:Fantomas.FormatConfig.incrIndent(System.Int32,Fantomas.FormatConfig.Context)">
<summary>
 Increase indent by i spaces
</summary>
</member>
<member name="M:Fantomas.FormatConfig.unindent(Fantomas.FormatConfig.Context)">
<summary>
 Unindent one more level based on configuration
</summary>
</member>
<member name="M:Fantomas.FormatConfig.indent(Fantomas.FormatConfig.Context)">
<summary>
 Indent one more level based on configuration
</summary>
</member>
<member name="">

</member>
<member name="T:Fantomas.FormatConfig">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Fantomas.SourceFilter.filterComments(Fantomas.SourceFilter.Token[])">
<summary>
 Given a list of token, attach comments to appropriate positions
</summary>
</member>
<member name="M:Fantomas.SourceFilter.|SupportedToken|_|(Fantomas.SourceFilter.Token)">
<summary>
 Keyword and identifier tokens have attached comments
</summary>
</member>
<member name="M:Fantomas.SourceFilter.|CommentBlocks|_|(Fantomas.SourceFilter.Token[])">
<summary>
 Retrieve comments in a list of lines, skip some whitespaces
</summary>
</member>
<member name="M:Fantomas.SourceFilter.|CommentBlock|_|(Fantomas.SourceFilter.Token[])">
<summary>
 Return a block of comments and the array fragment before the comment block
</summary>
</member>
<member name="M:Fantomas.SourceFilter.|Attributes|_|(Fantomas.SourceFilter.Token[])">
<summary>
 Recognize a list of attributes and return the array fragment before that
</summary>
</member>
<member name="M:Fantomas.SourceFilter.|Attribute|_|(Fantomas.SourceFilter.Token[])">
<summary>
 Recognize an attribute and skip it
</summary>
</member>
<member name="M:Fantomas.SourceFilter.|Spaces|(Fantomas.SourceFilter.Token[])">
<summary>
 Skip all spaces at the end of xs
</summary>
</member>
<member name="M:Fantomas.SourceFilter.searchBackward``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},``0[])">
<summary>
 Search an array starting from the end
</summary>
</member>
<member name="M:Fantomas.SourceFilter.tokenize(System.String)">
<summary>
 Return a list of tokens with line and column information
</summary>
</member>
<member name="">

</member>
<member name="T:Fantomas.SourceFilter.Array">

</member>
<member name="T:Fantomas.SourceFilter">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Fantomas.SourceParser.|FunType|(Microsoft.FSharp.Compiler.Ast.SynType,Microsoft.FSharp.Compiler.Ast.SynValInfo)">
<summary>
 Extract function arguments with their associated info
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Fantomas.SourceParser.|SimplePats|SPSTyped|(Microsoft.FSharp.Compiler.Ast.SynSimplePats)">
<summary>
 Not sure compiler generated SPIds are used elsewhere.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Fantomas.SourceParser.|DotGetApp|_|(Microsoft.FSharp.Compiler.Ast.SynExpr)">
<summary>
 Gather series of application for line breaking
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Fantomas.SourceParser.|Lambda|_|(Microsoft.FSharp.Compiler.Ast.SynExpr)">
<summary>
 Gather all arguments in lambda
</summary>
</member>
<member name="M:Fantomas.SourceParser.|InfixApps|_|(Microsoft.FSharp.Compiler.Ast.SynExpr)">
<summary>
 We should return the whole triple for convenience check
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Fantomas.SourceParser.|App|_|(Microsoft.FSharp.Compiler.Ast.SynExpr)">
<summary>
 Get all application params at once
</summary>
</member>
<member name="M:Fantomas.SourceParser.|Var|_|(Microsoft.FSharp.Compiler.Ast.SynExpr)">
<summary>
 This pattern is escaped by using OpName
</summary>
</member>
<member name="M:Fantomas.SourceParser.|OptVar|_|(Microsoft.FSharp.Compiler.Ast.SynExpr)">
<summary>
 We might have to narrow scope of this pattern to avoid incorrect usage
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Fantomas.SourceParser.|SequentialSimple|_|(Microsoft.FSharp.Compiler.Ast.SynExpr)">
<summary>
 Only recognize numbers; strings are ignored
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Fantomas.SourceParser.|Quote|_|(Microsoft.FSharp.Compiler.Ast.SynExpr)">
<summary>
 isRaw = true with &lt;@@ and @@&gt;
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Fantomas.SourceParser.|MFMember|MFStaticMember|MFConstructor|MFOverride|(Microsoft.FSharp.Compiler.Ast.MemberFlags)">
<summary>
 This pattern finds out which keyword to use
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Fantomas.SourceParser.|Const|Unresolved|(Microsoft.FSharp.Compiler.Ast.SynConst)">
<summary>
 Lose information about kinds of literals
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Fantomas.SourceParser.|Typar|(Microsoft.FSharp.Compiler.Ast.SynTypar)">
<summary>
 Use two spaces for symmetry
</summary>
</member>
<member name="M:Fantomas.SourceParser.|OpNameFull|(Fantomas.SourceParser.Identifier)">
<summary>
 Operators in their declaration form
</summary>
</member>
<member name="M:Fantomas.SourceParser.|OpName|(Fantomas.SourceParser.Identifier)">
<summary>
 Use infix operators in the short form
</summary>
</member>
<member name="">

</member>
<member name="M:Fantomas.SourceParser.|IdentOrKeyword|(Microsoft.FSharp.Compiler.Ast.Ident)">
<summary>
 Different from (|Ident|), this pattern also accepts keywords
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Fantomas.SourceParser">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Fantomas.SourceTransformer.Data`2">
<summary>
 This pattern prevents PropertyWithGetSet to be taken separately
</summary>
</member>
<member name="M:Fantomas.SourceTransformer.|MultilineBindingL|_|(Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Ast.SynBinding})">
<summary>
 Gather all multiline bindings. 
 This should be used before one-liner pattern.
</summary>
</member>
<member name="">

</member>
<member name="M:Fantomas.SourceTransformer.|MultilineMemberDefnL|_|(Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Ast.SynMemberDefn})">
<summary>
 Gather all multiline member definitions. 
 This should be used before one-liner pattern.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Fantomas.SourceTransformer.|PropertyWithGetSet|_|(Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Ast.SynBinding})">
<summary>
 Gather PropertyGetSet in one printing call. 
 Assume that PropertySet comes right after PropertyGet.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Fantomas.SourceTransformer.genComments``1(``0,Fantomas.FormatConfig.Context)">
<summary>
 Assume that this function is called on e with Range property
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Fantomas.SourceTransformer.content(Microsoft.FSharp.Compiler.Ast.SynConst,Fantomas.FormatConfig.Context)">
<summary>
 Get source string content based on range value
</summary>
</member>
<member name="">

</member>
<member name="M:Fantomas.SourceTransformer.hasParenthesis(Microsoft.FSharp.Compiler.Ast.SynExpr)">
<summary>
 Check if the expression already has surrounding parentheses
</summary>
</member>
<member name="M:Fantomas.SourceTransformer.multiline(Microsoft.FSharp.Compiler.Ast.SynExpr)">
<summary>
 Check whether an expression should be broken into multiple lines. 
 Notice that order of patterns matters due to non-disjoint property.
</summary>
</member>
<member name="">

</member>
<member name="T:Fantomas.SourceTransformer.List">

</member>
<member name="T:Fantomas.SourceTransformer">

</member>
</members>
</doc>
